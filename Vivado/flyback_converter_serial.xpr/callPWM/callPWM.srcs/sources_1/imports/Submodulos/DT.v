// -------------------------------------------------------------
// 
// File Name: D:\Github\FlybackConverter-FPGA-based-Digital-Twin\HDL Code Generation\Embedded_DT\flyback_dt\DT.v
// Created: 2023-07-06 02:36:05
// 
// Generated by MATLAB 9.11 and HDL Coder 3.19
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 8e-08
// Target subsystem base rate: 8e-08
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: DT
// Source Path: flyback_dt/DT
// Hierarchy Level: 0
// 
// Simulink model description for flyback_dt:
// 
// Symmetric FIR Filter
// This example shows how to use HDL Coder(TM) to check, generate,
// and verify HDL for a fixed-point symmetric FIR filter. 
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module DT
          (clk,
           error_DT,
           kp_DT,
           kp_divisor_DT,
           ki_DT,
           ki_multiplier_DT,
           alpha1_port_DT,
           Tt_DT,
           Tt_divisor_DT,
           PV_DT,
           MV_DT,
           p_action_dt,
           i_action_dt);


  input   clk;
  input   signed [15:0] error_DT;  // int16
  input   signed [15:0] kp_DT;  // int16
  input   signed [15:0] kp_divisor_DT;  // int16
  input   signed [15:0] ki_DT;  // int16
  input   signed [15:0] ki_multiplier_DT;  // int16
  input   signed [15:0] alpha1_port_DT;  // int16
  input   signed [15:0] Tt_DT;  // int16
  input   signed [15:0] Tt_divisor_DT;  // int16
  output  signed [15:0] PV_DT;  // int16
  output  signed [7:0] MV_DT;  // int8
  output  signed [15:0] p_action_dt;  // int16
  output  signed [15:0] i_action_dt;  // int16


  wire signed [15:0] Constant1_out1;  // int16
  wire signed [31:0] Product2_mul_temp;  // sfix32
  wire signed [15:0] Product2_out1;  // int16
  wire signed [16:0] Product2_out1_dtc;  // sfix17
  wire signed [31:0] Constant_out1;  // int32
  reg signed [15:0] Divide1_out1;  // int16
  wire signed [15:0] Constant4_out1;  // int16
  wire signed [31:0] Product4_mul_temp;  // sfix32
  wire signed [15:0] Product4_out1;  // int16
  wire signed [16:0] kp_DT_dtc;  // sfix17
  reg signed [15:0] Divide_out1;  // int16
  wire signed [31:0] Product_mul_temp;  // sfix32
  wire signed [15:0] Product_out1;  // int16
  wire signed [31:0] Product5_mul_temp;  // sfix32
  wire signed [15:0] Product5_out1;  // int16
  wire signed [16:0] alpha1_port_DT_dtc;  // sfix17
  wire signed [16:0] Tt_DT_dtc;  // sfix17
  wire signed [31:0] Product1_mul_temp;  // sfix32
  wire signed [15:0] Product1_out1;  // int16
  reg signed [15:0] Divide5_out1;  // int16
  reg signed [15:0] Divide4_out1;  // int16
  wire signed [15:0] Saturation_out1;  // int16
  wire signed [15:0] Add1_out1;  // int16
  wire signed [15:0] Add3_out1;  // int16
  wire signed [31:0] Product6_mul_temp;  // sfix32
  wire signed [15:0] Product6_out1;  // int16
  wire signed [15:0] Add2_out1;  // int16
  wire signed [15:0] Discrete_Time_Integrator1_indtc;  // sfix16
  wire signed [31:0] gain_mul_temp;  // sfix32_En37
  wire signed [15:0] Discrete_Time_Integrator1_u_gain;  // sfix16
  wire signed [15:0] Discrete_Time_Integrator1_u_dtc;  // int16
  reg signed [15:0] Discrete_Time_Integrator1_x_reg;  // int16
  wire signed [15:0] Discrete_Time_Integrator1_u_add;  // int16
  wire signed [15:0] s_input_acc_cast;  // sfix16
  reg signed [15:0] s_state_out1;  // int16
  reg signed [15:0] s_state_out2_1;  // int16
  wire signed [15:0] s_denom_gain2;  // sfix16
  wire signed [15:0] s_denom_gain1;  // sfix16
  wire signed [15:0] s_denom_acc_out1;  // sfix16
  wire signed [15:0] s_denom_acc_out2;  // sfix16
  wire signed [15:0] s_state_cast;  // int16
  wire signed [15:0] s_nume_gain1;  // sfix16
  wire signed [15:0] s_output_cast;  // int16
  wire signed [31:0] Constant2_out1;  // int32
  wire signed [47:0] Product3_mul_temp;  // sfix48
  wire signed [15:0] Product3_out1;  // int16
  wire signed [16:0] Product3_out1_dtc;  // sfix17
  wire signed [15:0] Constant3_out1;  // int16
  reg signed [15:0] Divide2_out1;  // int16
  wire signed [16:0] Divide2_out1_dtc;  // sfix17
  wire signed [15:0] Constant5_out1;  // int16
  reg signed [15:0] Divide3_out1;  // int16
  wire signed [15:0] p_action;  // int16
  wire signed [15:0] i_action;  // int16
  wire signed [15:0] PV;  // int16
  reg signed [31:0] Divide1_c;  // sfix32
  reg signed [31:0] Divide1_div_temp;  // sfix32
  reg signed [16:0] Divide_c;  // sfix17
  reg signed [17:0] Divide_div_temp;  // sfix18
  reg signed [17:0] Divide_t_0_0;  // sfix18
  reg signed [16:0] Divide5_c;  // sfix17
  reg signed [17:0] Divide5_div_temp;  // sfix18
  reg signed [17:0] Divide5_t_0_0;  // sfix18
  reg signed [16:0] Divide4_c;  // sfix17
  reg signed [17:0] Divide4_div_temp;  // sfix18
  reg signed [17:0] Divide4_t_0_0;  // sfix18
  reg signed [16:0] Divide2_c;  // sfix17
  reg signed [17:0] Divide2_div_temp;  // sfix18
  reg signed [17:0] Divide2_t_0_0;  // sfix18
  reg signed [16:0] Divide3_c;  // sfix17
  reg signed [17:0] Divide3_div_temp;  // sfix18
  reg signed [17:0] Divide3_t_0_0;  // sfix18

  initial begin
    Discrete_Time_Integrator1_x_reg = 16'sb0000000000000000;
    s_state_out2_1 = 16'sb0000000000000000;
    s_state_out1 = 16'sb0000000000000000;
  end

  assign Constant1_out1 = 16'sb0000000000000011;


  assign Product2_mul_temp = error_DT * Constant1_out1;
  assign Product2_out1 = Product2_mul_temp[15:0];


  assign Product2_out1_dtc = {Product2_out1[15], Product2_out1};



  assign Constant_out1 = 32'sb00000000000000010000000000000000;


  always @(Constant_out1, Product2_out1_dtc) begin
    Divide1_div_temp = 32'sb00000000000000000000000000000000;
    if (Constant_out1 == 32'sb00000000000000000000000000000000) begin
      if (Product2_out1_dtc < 17'sb00000000000000000) begin
        Divide1_c = 32'sb10000000000000000000000000000000;
      end
      else begin
        Divide1_c = 32'sb01111111111111111111111111111111;
      end
    end
    else begin
      Divide1_div_temp = Product2_out1_dtc / Constant_out1;
      Divide1_c = Divide1_div_temp;
    end
    if ((Divide1_c[31] == 1'b0) && (Divide1_c[30:15] != 16'b0000000000000000)) begin
      Divide1_out1 = 16'sb0111111111111111;
    end
    else if ((Divide1_c[31] == 1'b1) && (Divide1_c[30:15] != 16'b1111111111111111)) begin
      Divide1_out1 = 16'sb1000000000000000;
    end
    else begin
      Divide1_out1 = Divide1_c[15:0];
    end
  end


  assign Constant4_out1 = 16'sb0000001111101000;


  assign Product4_mul_temp = Divide1_out1 * Constant4_out1;
  assign Product4_out1 = Product4_mul_temp[15:0];


  assign kp_DT_dtc = {kp_DT[15], kp_DT};



  always @(kp_DT_dtc, kp_divisor_DT) begin
    Divide_div_temp = 18'sb000000000000000000;
    Divide_t_0_0 = 18'sb000000000000000000;
    if (kp_divisor_DT == 16'sb0000000000000000) begin
      if (kp_DT_dtc < 17'sb00000000000000000) begin
        Divide_c = 17'sb10000000000000000;
      end
      else begin
        Divide_c = 17'sb01111111111111111;
      end
    end
    else begin
      Divide_t_0_0 = {kp_DT_dtc[16], kp_DT_dtc};
      Divide_div_temp = Divide_t_0_0 / kp_divisor_DT;
      if ((Divide_div_temp[17] == 1'b0) && (Divide_div_temp[16] != 1'b0)) begin
        Divide_c = 17'sb01111111111111111;
      end
      else if ((Divide_div_temp[17] == 1'b1) && (Divide_div_temp[16] != 1'b1)) begin
        Divide_c = 17'sb10000000000000000;
      end
      else begin
        Divide_c = Divide_div_temp[16:0];
      end
    end
    if ((Divide_c[16] == 1'b0) && (Divide_c[15] != 1'b0)) begin
      Divide_out1 = 16'sb0111111111111111;
    end
    else if ((Divide_c[16] == 1'b1) && (Divide_c[15] != 1'b1)) begin
      Divide_out1 = 16'sb1000000000000000;
    end
    else begin
      Divide_out1 = Divide_c[15:0];
    end
  end


  assign Product_mul_temp = Product4_out1 * Divide_out1;
  assign Product_out1 = Product_mul_temp[15:0];


  assign Product5_mul_temp = ki_DT * ki_multiplier_DT;
  assign Product5_out1 = Product5_mul_temp[15:0];


  assign alpha1_port_DT_dtc = {alpha1_port_DT[15], alpha1_port_DT};



  assign Tt_DT_dtc = {Tt_DT[15], Tt_DT};



  assign Product1_mul_temp = Product4_out1 * Product5_out1;
  assign Product1_out1 = Product1_mul_temp[15:0];


  always @(Tt_DT_dtc, Tt_divisor_DT) begin
    Divide5_div_temp = 18'sb000000000000000000;
    Divide5_t_0_0 = 18'sb000000000000000000;
    if (Tt_divisor_DT == 16'sb0000000000000000) begin
      if (Tt_DT_dtc < 17'sb00000000000000000) begin
        Divide5_c = 17'sb10000000000000000;
      end
      else begin
        Divide5_c = 17'sb01111111111111111;
      end
    end
    else begin
      Divide5_t_0_0 = {Tt_DT_dtc[16], Tt_DT_dtc};
      Divide5_div_temp = Divide5_t_0_0 / Tt_divisor_DT;
      if ((Divide5_div_temp[17] == 1'b0) && (Divide5_div_temp[16] != 1'b0)) begin
        Divide5_c = 17'sb01111111111111111;
      end
      else if ((Divide5_div_temp[17] == 1'b1) && (Divide5_div_temp[16] != 1'b1)) begin
        Divide5_c = 17'sb10000000000000000;
      end
      else begin
        Divide5_c = Divide5_div_temp[16:0];
      end
    end
    if ((Divide5_c[16] == 1'b0) && (Divide5_c[15] != 1'b0)) begin
      Divide5_out1 = 16'sb0111111111111111;
    end
    else if ((Divide5_c[16] == 1'b1) && (Divide5_c[15] != 1'b1)) begin
      Divide5_out1 = 16'sb1000000000000000;
    end
    else begin
      Divide5_out1 = Divide5_c[15:0];
    end
  end


  always @(Divide5_out1, alpha1_port_DT_dtc) begin
    Divide4_div_temp = 18'sb000000000000000000;
    Divide4_t_0_0 = 18'sb000000000000000000;
    if (Divide5_out1 == 16'sb0000000000000000) begin
      if (alpha1_port_DT_dtc < 17'sb00000000000000000) begin
        Divide4_c = 17'sb10000000000000000;
      end
      else begin
        Divide4_c = 17'sb01111111111111111;
      end
    end
    else begin
      Divide4_t_0_0 = {alpha1_port_DT_dtc[16], alpha1_port_DT_dtc};
      Divide4_div_temp = Divide4_t_0_0 / Divide5_out1;
      if ((Divide4_div_temp[17] == 1'b0) && (Divide4_div_temp[16] != 1'b0)) begin
        Divide4_c = 17'sb01111111111111111;
      end
      else if ((Divide4_div_temp[17] == 1'b1) && (Divide4_div_temp[16] != 1'b1)) begin
        Divide4_c = 17'sb10000000000000000;
      end
      else begin
        Divide4_c = Divide4_div_temp[16:0];
      end
    end
    if ((Divide4_c[16] == 1'b0) && (Divide4_c[15] != 1'b0)) begin
      Divide4_out1 = 16'sb0111111111111111;
    end
    else if ((Divide4_c[16] == 1'b1) && (Divide4_c[15] != 1'b1)) begin
      Divide4_out1 = 16'sb1000000000000000;
    end
    else begin
      Divide4_out1 = Divide4_c[15:0];
    end
  end


  assign Add3_out1 = Saturation_out1 - Add1_out1;


  assign Product6_mul_temp = Add3_out1 * Divide4_out1;
  assign Product6_out1 = Product6_mul_temp[15:0];


  assign Add2_out1 = Product1_out1 + Product6_out1;


  assign Discrete_Time_Integrator1_indtc = Add2_out1;



  assign gain_mul_temp = 16'sb0010101011110011 * Discrete_Time_Integrator1_indtc;
  assign Discrete_Time_Integrator1_u_gain = {16{gain_mul_temp[31]}};



  assign Discrete_Time_Integrator1_u_dtc = Discrete_Time_Integrator1_u_gain;



  assign Discrete_Time_Integrator1_u_add = Discrete_Time_Integrator1_x_reg + Discrete_Time_Integrator1_u_dtc;



  always @(posedge clk)
    begin : Discrete_Time_Integrator1_reg_process
      Discrete_Time_Integrator1_x_reg <= Discrete_Time_Integrator1_u_add;
    end


  assign Add1_out1 = Product_out1 + Discrete_Time_Integrator1_x_reg;


  assign Saturation_out1 = (Add1_out1 > 16'sb0000000011111111 ? 16'sb0000000011111111 :
              (Add1_out1 < 16'sb0000000000000000 ? 16'sb0000000000000000 :
              Add1_out1));


  assign s_input_acc_cast = Saturation_out1;



  always @(posedge clk)
    begin : s_state_out2_process
      s_state_out2_1 <= s_state_out1;
    end



  assign s_denom_gain2 = s_state_out2_1;



  assign s_denom_gain1 = s_state_out1;



  assign s_denom_acc_out1 = s_input_acc_cast - s_denom_gain1;



  assign s_denom_acc_out2 = s_denom_acc_out1 - s_denom_gain2;



  assign s_state_cast = s_denom_acc_out2;



  always @(posedge clk)
    begin : s_state_out1_1_process
      s_state_out1 <= s_state_cast;
    end



  assign s_nume_gain1 = s_state_out1;



  assign s_output_cast = s_nume_gain1;


  assign Constant2_out1 = 32'sb00000000000000001111111111111010;


  assign Product3_mul_temp = s_output_cast * Constant2_out1;
  assign Product3_out1 = Product3_mul_temp[15:0];


  assign Product3_out1_dtc = {Product3_out1[15], Product3_out1};



  assign Constant3_out1 = 16'sb0000000000000011;


  always @(Constant3_out1, Product3_out1_dtc) begin
    Divide2_div_temp = 18'sb000000000000000000;
    Divide2_t_0_0 = 18'sb000000000000000000;
    if (Constant3_out1 == 16'sb0000000000000000) begin
      if (Product3_out1_dtc < 17'sb00000000000000000) begin
        Divide2_c = 17'sb10000000000000000;
      end
      else begin
        Divide2_c = 17'sb01111111111111111;
      end
    end
    else begin
      Divide2_t_0_0 = {Product3_out1_dtc[16], Product3_out1_dtc};
      Divide2_div_temp = Divide2_t_0_0 / Constant3_out1;
      if ((Divide2_div_temp[17] == 1'b0) && (Divide2_div_temp[16] != 1'b0)) begin
        Divide2_c = 17'sb01111111111111111;
      end
      else if ((Divide2_div_temp[17] == 1'b1) && (Divide2_div_temp[16] != 1'b1)) begin
        Divide2_c = 17'sb10000000000000000;
      end
      else begin
        Divide2_c = Divide2_div_temp[16:0];
      end
    end
    if ((Divide2_c[16] == 1'b0) && (Divide2_c[15] != 1'b0)) begin
      Divide2_out1 = 16'sb0111111111111111;
    end
    else if ((Divide2_c[16] == 1'b1) && (Divide2_c[15] != 1'b1)) begin
      Divide2_out1 = 16'sb1000000000000000;
    end
    else begin
      Divide2_out1 = Divide2_c[15:0];
    end
  end


  assign Divide2_out1_dtc = {Divide2_out1[15], Divide2_out1};



  assign Constant5_out1 = 16'sb0000001111101000;


  always @(Constant5_out1, Divide2_out1_dtc) begin
    Divide3_div_temp = 18'sb000000000000000000;
    Divide3_t_0_0 = 18'sb000000000000000000;
    if (Constant5_out1 == 16'sb0000000000000000) begin
      if (Divide2_out1_dtc < 17'sb00000000000000000) begin
        Divide3_c = 17'sb10000000000000000;
      end
      else begin
        Divide3_c = 17'sb01111111111111111;
      end
    end
    else begin
      Divide3_t_0_0 = {Divide2_out1_dtc[16], Divide2_out1_dtc};
      Divide3_div_temp = Divide3_t_0_0 / Constant5_out1;
      if ((Divide3_div_temp[17] == 1'b0) && (Divide3_div_temp[16] != 1'b0)) begin
        Divide3_c = 17'sb01111111111111111;
      end
      else if ((Divide3_div_temp[17] == 1'b1) && (Divide3_div_temp[16] != 1'b1)) begin
        Divide3_c = 17'sb10000000000000000;
      end
      else begin
        Divide3_c = Divide3_div_temp[16:0];
      end
    end
    if ((Divide3_c[16] == 1'b0) && (Divide3_c[15] != 1'b0)) begin
      Divide3_out1 = 16'sb0111111111111111;
    end
    else if ((Divide3_c[16] == 1'b1) && (Divide3_c[15] != 1'b1)) begin
      Divide3_out1 = 16'sb1000000000000000;
    end
    else begin
      Divide3_out1 = Divide3_c[15:0];
    end
  end


  assign PV_DT = Divide3_out1;


  assign MV_DT = Saturation_out1[7:0];


  assign p_action = Product_out1;


  assign p_action_dt = p_action;

  assign i_action = Discrete_Time_Integrator1_x_reg;


  assign i_action_dt = i_action;

endmodule  // DT

