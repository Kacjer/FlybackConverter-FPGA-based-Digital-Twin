// -------------------------------------------------------------
// 
// File Name: D:\Github\FlybackConverter-FPGA-based-Digital-Twin\HDL Code Generation\IOPID_FOMCON\iopid\IOPID.v
// Created: 2023-07-11 00:36:12
// 
// Generated by MATLAB 9.11 and HDL Coder 3.19
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 8e-08
// Target subsystem base rate: 8e-08
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: IOPID
// Source Path: iopid/IOPID
// Hierarchy Level: 0
// 
// Simulink model description for iopid:
// 
// Symmetric FIR Filter
// This example shows how to use HDL Coder(TM) to check, generate,
// and verify HDL for a fixed-point symmetric FIR filter. 
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module IOPID
          (clk,
           error,
           saturated_MV);


  input   clk;
  input   signed [31:0] error;  // int32
  output  signed [15:0] saturated_MV;  // int16


  wire signed [63:0] Multiply_mul_temp;  // sfix64_En21
  wire signed [31:0] Multiply_out1;  // int32
  wire signed [32:0] Multiply_out1_dtc;  // sfix33
  wire signed [31:0] Constant_out1;  // int32
  reg signed [31:0] Divide_out1;  // int32
  wire signed [63:0] Multiply1_mul_temp;  // sfix64_En29
  wire signed [31:0] Multiply1_out1;  // int32
  wire signed [31:0] s_input_acc_cast;  // sfix32
  wire signed [31:0] s_state_cast;  // int32
  reg signed [31:0] s_state_out1_1;  // int32
  wire signed [32:0] denom_gain1_in0;  // sfix33
  wire signed [32:0] denom_gain1_1;  // sfix33
  wire signed [31:0] s_denom_gain1;  // sfix32
  wire signed [31:0] s_denom_acc_out1;  // sfix32
  wire signed [63:0] nume_gain_b0_mul_temp;  // sfix64
  wire signed [31:0] s_nume_gain_b0;  // sfix32
  wire signed [63:0] nume_gain1_mul_temp;  // sfix64
  wire signed [31:0] s_nume_gain1;  // sfix32
  wire signed [31:0] s_nume_acc_out1;  // sfix32
  wire signed [31:0] s_output_cast;  // int32
  wire signed [63:0] Multiply2_cast;  // sfix64_En14
  wire signed [31:0] Multiply2_out1;  // int32
  wire signed [32:0] Multiply2_out1_dtc;  // sfix33
  wire signed [31:0] Constant1_out1;  // int32
  reg signed [31:0] Divide1_out1;  // int32
  wire signed [31:0] Saturation_out1;  // int32
  wire signed [15:0] Data_Type_Conversion2_out1;  // int16
  reg signed [32:0] Divide_c;  // sfix33
  reg signed [33:0] Divide_div_temp;  // sfix34
  reg signed [33:0] Divide_t_0_0;  // sfix34
  reg signed [32:0] Divide1_c;  // sfix33
  reg signed [33:0] Divide1_div_temp;  // sfix34
  reg signed [33:0] Divide1_t_0_0;  // sfix34

  initial begin
    s_state_out1_1 = 32'sb00000000000000000000000000000000;
  end

  assign Multiply_mul_temp = 32'sb01111101000000000000000000000000 * error;
  assign Multiply_out1 = Multiply_mul_temp[52:21];


  assign Multiply_out1_dtc = {Multiply_out1[31], Multiply_out1};



  assign Constant_out1 = 32'sb00000000000000010000000000000000;


  always @(Constant_out1, Multiply_out1_dtc) begin
    Divide_div_temp = 34'sh000000000;
    Divide_t_0_0 = 34'sh000000000;
    if (Constant_out1 == 32'sb00000000000000000000000000000000) begin
      if (Multiply_out1_dtc < 33'sh000000000) begin
        Divide_c = 33'sh100000000;
      end
      else begin
        Divide_c = 33'sh0FFFFFFFF;
      end
    end
    else begin
      Divide_t_0_0 = {Multiply_out1_dtc[32], Multiply_out1_dtc};
      Divide_div_temp = Divide_t_0_0 / Constant_out1;
      if ((Divide_div_temp[33] == 1'b0) && (Divide_div_temp[32] != 1'b0)) begin
        Divide_c = 33'sh0FFFFFFFF;
      end
      else if ((Divide_div_temp[33] == 1'b1) && (Divide_div_temp[32] != 1'b1)) begin
        Divide_c = 33'sh100000000;
      end
      else begin
        Divide_c = Divide_div_temp[32:0];
      end
    end
    if ((Divide_c[32] == 1'b0) && (Divide_c[31] != 1'b0)) begin
      Divide_out1 = 32'sb01111111111111111111111111111111;
    end
    else if ((Divide_c[32] == 1'b1) && (Divide_c[31] != 1'b1)) begin
      Divide_out1 = 32'sb10000000000000000000000000000000;
    end
    else begin
      Divide_out1 = Divide_c[31:0];
    end
  end


  assign Multiply1_mul_temp = 32'sb01101001100110011001100110011010 * Divide_out1;
  assign Multiply1_out1 = Multiply1_mul_temp[60:29];


  assign s_input_acc_cast = Multiply1_out1;



  always @(posedge clk)
    begin : s_state_out1_process
      s_state_out1_1 <= s_state_cast;
    end



  assign denom_gain1_1 = {s_state_out1_1[31], s_state_out1_1};
  assign denom_gain1_in0 =  - (denom_gain1_1);
  assign s_denom_gain1 = denom_gain1_in0[31:0];



  assign s_denom_acc_out1 = s_input_acc_cast - s_denom_gain1;



  assign s_state_cast = s_denom_acc_out1;



  assign nume_gain_b0_mul_temp = 32'sb00000000000000000000000000000011 * s_state_cast;
  assign s_nume_gain_b0 = nume_gain_b0_mul_temp[31:0];



  assign nume_gain1_mul_temp = 32'sb11111111111111111111111111111101 * s_state_out1_1;
  assign s_nume_gain1 = nume_gain1_mul_temp[31:0];



  assign s_nume_acc_out1 = s_nume_gain_b0 + s_nume_gain1;



  assign s_output_cast = s_nume_acc_out1;


  assign Multiply2_cast = {{2{s_output_cast[31]}}, {s_output_cast, 30'b000000000000000000000000000000}};
  assign Multiply2_out1 = Multiply2_cast[45:14];


  assign Multiply2_out1_dtc = {Multiply2_out1[31], Multiply2_out1};



  assign Constant1_out1 = 32'sb00000000000000000000000000000011;


  always @(Constant1_out1, Multiply2_out1_dtc) begin
    Divide1_div_temp = 34'sh000000000;
    Divide1_t_0_0 = 34'sh000000000;
    if (Constant1_out1 == 32'sb00000000000000000000000000000000) begin
      if (Multiply2_out1_dtc < 33'sh000000000) begin
        Divide1_c = 33'sh100000000;
      end
      else begin
        Divide1_c = 33'sh0FFFFFFFF;
      end
    end
    else begin
      Divide1_t_0_0 = {Multiply2_out1_dtc[32], Multiply2_out1_dtc};
      Divide1_div_temp = Divide1_t_0_0 / Constant1_out1;
      if ((Divide1_div_temp[33] == 1'b0) && (Divide1_div_temp[32] != 1'b0)) begin
        Divide1_c = 33'sh0FFFFFFFF;
      end
      else if ((Divide1_div_temp[33] == 1'b1) && (Divide1_div_temp[32] != 1'b1)) begin
        Divide1_c = 33'sh100000000;
      end
      else begin
        Divide1_c = Divide1_div_temp[32:0];
      end
    end
    if ((Divide1_c[32] == 1'b0) && (Divide1_c[31] != 1'b0)) begin
      Divide1_out1 = 32'sb01111111111111111111111111111111;
    end
    else if ((Divide1_c[32] == 1'b1) && (Divide1_c[31] != 1'b1)) begin
      Divide1_out1 = 32'sb10000000000000000000000000000000;
    end
    else begin
      Divide1_out1 = Divide1_c[31:0];
    end
  end


  assign Saturation_out1 = (Divide1_out1 > 32'sb00000000000000000000000011111111 ? 32'sb00000000000000000000000011111111 :
              (Divide1_out1 < 32'sb00000000000000000000000000000000 ? 32'sb00000000000000000000000000000000 :
              Divide1_out1));


  assign Data_Type_Conversion2_out1 = Saturation_out1[15:0];


  assign saturated_MV = Data_Type_Conversion2_out1;

endmodule  // IOPID

